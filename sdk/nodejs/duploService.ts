// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as enums from "./types/enums";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ### Deploy NGINX service using DuploCloud Platform's native container agent.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Before creating an NGINX service, you must first set up the infrastructure and tenant. Below is the resource for creating the infrastructure.
 * const infra = new duplocloud.Infrastructure("infra", {
 *     infraName: "dev",
 *     cloud: 0,
 *     region: "us-east-1",
 *     enableK8Cluster: false,
 *     addressPrefix: "10.13.0.0/16",
 * });
 * // Use the infrastructure name as the 'plan_id' from the 'duplocloud_infrastructure' resource while creating tenant.
 * const tenant = new duplocloud.Tenant("tenant", {
 *     accountName: "dev",
 *     planId: infra.infraName,
 * });
 * // You will need a DuploCloud host to launch the Duplo service, so create a host using following resource configuration.
 * const image = duplocloud.getNativeHostImageOutput({
 *     tenantId: tenant.tenantId,
 *     isKubernetes: false,
 * });
 * const host = new duplocloud.AwsHost("host", {
 *     tenantId: tenant.tenantId,
 *     friendlyName: "host01",
 *     imageId: image.apply(image => image.imageId),
 *     capacity: "t3a.small",
 *     agentPlatform: 0,
 *     zone: 0,
 *     userAccount: tenant.accountName,
 *     keypairType: 1,
 * });
 * const myservice = new duplocloud.DuploService("myservice", {
 *     tenantId: tenant.tenantId,
 *     name: "myservice",
 *     agentPlatform: 0,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 * });
 * ```
 *
 * ### Deploy NGINX service inside the 'nonprod' tenant using DuploCloud Platform's native container agent with host networking and the environment variables - NGINX_HOST and NGINX_PORT
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'nonprod' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "nonprod",
 * });
 * // Create a data source to retrieve the Machine Image ID to be used by the host
 * const image = tenant.then(tenant => duplocloud.getNativeHostImage({
 *     tenantId: tenant.id,
 *     isKubernetes: false,
 * }));
 * const host = new duplocloud.AwsHost("host", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     friendlyName: "host01",
 *     imageId: image.then(image => image.imageId),
 *     capacity: "t3a.small",
 *     agentPlatform: 0,
 *     zone: 0,
 *     userAccount: tenant.then(tenant => tenant.name),
 *     keypairType: 1,
 * });
 * // Create the DuploCloud service
 * const myservice = new duplocloud.DuploService("myservice", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "myservice",
 *     agentPlatform: 0,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 *     extraConfig: JSON.stringify({
 *         NGINX_HOST: "foo",
 *         NGINX_PORT: "8080",
 *     }),
 *     otherDockerHostConfig: JSON.stringify({
 *         NetworkMode: "host",
 *         CapAdd: ["NET_ADMIN"],
 *     }),
 * });
 * ```
 *
 * ### Deploy NGINX service named nginx inside the 'dev' tenant and set the resource requests and limits. Set cpu requests and limits to 200m and 300m respectively and set memory requests and limits to 100Mi and 300Mi respectively
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "dev",
 * });
 * // Assuming that a host already exists in the tenant, create a service
 * const nginx = new duplocloud.DuploService("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx",
 *     agentPlatform: 7,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 *     otherDockerConfig: JSON.stringify({
 *         Resources: {
 *             requests: {
 *                 cpu: "200m",
 *                 memory: "100Mi",
 *             },
 *             limits: {
 *                 cpu: "300m",
 *                 memory: "300Mi",
 *             },
 *         },
 *     }),
 * });
 * ```
 *
 * ### Deploy an Nginx service named nginx inside the prod tenant and mount these environment variables from the kubernetes secrets - 1. FOO: bar 2. PING: pong
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'prod' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "prod",
 * });
 * // Create a secret with the env vars values 1. FOO: bar 2. PING: pong if it does not exist
 * const nginx = new duplocloud.K8Secret("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     secretName: "nginx-secret",
 *     secretType: "Opaque",
 *     secretData: JSON.stringify({
 *         FOO: "bar",
 *         PING: "pong",
 *     }),
 * });
 * // Assuming that a host exists in the tenant.
 * const nginxDuploService = new duplocloud.DuploService("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx",
 *     agentPlatform: 7,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 *     otherDockerConfig: pulumi.jsonStringify({
 *         EnvFrom: [{
 *             secretRef: {
 *                 name: nginx.secretName,
 *             },
 *         }],
 *     }),
 * });
 * ```
 *
 * ### Deploy an Nginx service named nginx inside the dev tenant, and mount these environment variables from the kubernetes configmap - 1. FOO: bar 2. PING: pong
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "dev",
 * });
 * // Create a configmap with the env vars values 1. FOO: bar 2. PING: pong if it does not exists
 * const nginx = new duplocloud.K8ConfigMap("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx-cm",
 *     data: JSON.stringify({
 *         FOO: "bar",
 *         PING: "pong",
 *     }),
 * });
 * // Ensure that the host is also created in the tenant.
 * const nginxDuploService = new duplocloud.DuploService("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx",
 *     agentPlatform: 7,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 *     otherDockerConfig: pulumi.jsonStringify({
 *         EnvFrom: [{
 *             configMapRef: {
 *                 name: nginx.name,
 *             },
 *         }],
 *     }),
 * });
 * ```
 *
 * ### Deploy an Nginx service named nginx inside the dev tenant, and set the replica count to 5
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "dev",
 * });
 * // Ensure that the host is also created in the tenant.
 * const nginx = new duplocloud.DuploService("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx",
 *     agentPlatform: 7,
 *     dockerImage: "nginx:latest",
 *     replicas: 5,
 * });
 * ```
 *
 * ### Deploy an Nginx service named nginx with liveliness probe. Create it inside the dev tenant which already exists.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as duplocloud from "@pulumi/duplocloud";
 *
 * // Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
 * const tenant = duplocloud.getTenant({
 *     name: "dev",
 * });
 * // Assuming a host already exists in the tenant, create the duplo service
 * const nginx = new duplocloud.DuploService("nginx", {
 *     tenantId: tenant.then(tenant => tenant.id),
 *     name: "nginx",
 *     agentPlatform: 7,
 *     dockerImage: "nginx:latest",
 *     replicas: 1,
 *     otherDockerConfig: JSON.stringify({
 *         LivenessProbe: {
 *             initialDelaySeconds: 10,
 *             periodSeconds: 30,
 *             successThreshold: 1,
 *             httpGet: {
 *                 path: "/health",
 *                 port: 80,
 *             },
 *         },
 *     }),
 * });
 * ```
 *
 * ## Import
 *
 * Example: Importing an existing service
 *
 *  - *TENANT_ID* is the tenant GUID
 *
 *  - *NAME* is the name of the service
 *
 * # 
 *
 * ```sh
 * $ pulumi import duplocloud:index/duploService:DuploService myservice v2/subscriptions/*TENANT_ID*&#47;ReplicationControllerApiV2/*NAME*
 * ```
 */
export class DuploService extends pulumi.CustomResource {
    /**
     * Get an existing DuploService resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DuploServiceState, opts?: pulumi.CustomResourceOptions): DuploService {
        return new DuploService(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'duplocloud:index/duploService:DuploService';

    /**
     * Returns true if the given object is an instance of DuploService.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DuploService {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DuploService.__pulumiType;
    }

    /**
     * The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
     * `7` : Linux container agent for Kubernetes
     */
    public readonly agentPlatform!: pulumi.Output<number | undefined>;
    public readonly allocationTags!: pulumi.Output<string | undefined>;
    /**
     * Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
     */
    public readonly anyHostAllowed!: pulumi.Output<boolean | undefined>;
    /**
     * The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
     * `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
     */
    public readonly cloud!: pulumi.Output<number | undefined>;
    /**
     * Whether or not the service gets it's cloud credentials from Kubernetes service account.
     */
    public readonly cloudCredsFromK8sServiceAccount!: pulumi.Output<boolean | undefined>;
    public readonly commands!: pulumi.Output<string | undefined>;
    /**
     * The docker image to use for the launched container(s).
     */
    public readonly dockerImage!: pulumi.Output<string>;
    /**
     * The service domain (whichever fqdnEx or fqdn which is non empty)
     */
    public /*out*/ readonly domain!: pulumi.Output<string>;
    public readonly extraConfig!: pulumi.Output<string | undefined>;
    /**
     * if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
     * the resource.
     */
    public readonly forceRecreateOnVolumesChange!: pulumi.Output<boolean | undefined>;
    /**
     * Whether or not to force a StatefulSet to be created.
     */
    public readonly forceStatefulSet!: pulumi.Output<boolean | undefined>;
    /**
     * The fully qualified domain associated with the service
     */
    public /*out*/ readonly fqdn!: pulumi.Output<string>;
    /**
     * External fully qualified domain associated with the service
     */
    public /*out*/ readonly fqdnEx!: pulumi.Output<string>;
    public readonly hpaSpecs!: pulumi.Output<string>;
    /**
     * The index of the service.
     */
    public /*out*/ readonly index!: pulumi.Output<number>;
    /**
     * Whether or not to enable DaemonSet.
     */
    public readonly isDaemonset!: pulumi.Output<boolean | undefined>;
    /**
     * Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
     */
    public readonly isUniqueK8sNodeRequired!: pulumi.Output<boolean | undefined>;
    public readonly lbSyncedDeployment!: pulumi.Output<boolean | undefined>;
    /**
     * The name of the service to create.
     */
    public readonly name!: pulumi.Output<string>;
    public readonly otherDockerConfig!: pulumi.Output<string>;
    public readonly otherDockerHostConfig!: pulumi.Output<string | undefined>;
    /**
     * The service's parent domain
     */
    public /*out*/ readonly parentDomain!: pulumi.Output<string>;
    /**
     * Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
     */
    public readonly replicaCollocationAllowed!: pulumi.Output<boolean>;
    /**
     * The number of container replicas to deploy.
     */
    public readonly replicas!: pulumi.Output<number | undefined>;
    public readonly replicasMatchingAsgName!: pulumi.Output<string | undefined>;
    /**
     * Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
     */
    public readonly shouldSpreadAcrossZones!: pulumi.Output<boolean | undefined>;
    public /*out*/ readonly tags!: pulumi.Output<outputs.DuploServiceTag[]>;
    /**
     * The GUID of the tenant that the service will be created in.
     */
    public readonly tenantId!: pulumi.Output<string>;
    /**
     * Volumes to be attached to pod.
     */
    public readonly volumes!: pulumi.Output<string | undefined>;

    /**
     * Create a DuploService resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DuploServiceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DuploServiceArgs | DuploServiceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DuploServiceState | undefined;
            resourceInputs["agentPlatform"] = state ? state.agentPlatform : undefined;
            resourceInputs["allocationTags"] = state ? state.allocationTags : undefined;
            resourceInputs["anyHostAllowed"] = state ? state.anyHostAllowed : undefined;
            resourceInputs["cloud"] = state ? state.cloud : undefined;
            resourceInputs["cloudCredsFromK8sServiceAccount"] = state ? state.cloudCredsFromK8sServiceAccount : undefined;
            resourceInputs["commands"] = state ? state.commands : undefined;
            resourceInputs["dockerImage"] = state ? state.dockerImage : undefined;
            resourceInputs["domain"] = state ? state.domain : undefined;
            resourceInputs["extraConfig"] = state ? state.extraConfig : undefined;
            resourceInputs["forceRecreateOnVolumesChange"] = state ? state.forceRecreateOnVolumesChange : undefined;
            resourceInputs["forceStatefulSet"] = state ? state.forceStatefulSet : undefined;
            resourceInputs["fqdn"] = state ? state.fqdn : undefined;
            resourceInputs["fqdnEx"] = state ? state.fqdnEx : undefined;
            resourceInputs["hpaSpecs"] = state ? state.hpaSpecs : undefined;
            resourceInputs["index"] = state ? state.index : undefined;
            resourceInputs["isDaemonset"] = state ? state.isDaemonset : undefined;
            resourceInputs["isUniqueK8sNodeRequired"] = state ? state.isUniqueK8sNodeRequired : undefined;
            resourceInputs["lbSyncedDeployment"] = state ? state.lbSyncedDeployment : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["otherDockerConfig"] = state ? state.otherDockerConfig : undefined;
            resourceInputs["otherDockerHostConfig"] = state ? state.otherDockerHostConfig : undefined;
            resourceInputs["parentDomain"] = state ? state.parentDomain : undefined;
            resourceInputs["replicaCollocationAllowed"] = state ? state.replicaCollocationAllowed : undefined;
            resourceInputs["replicas"] = state ? state.replicas : undefined;
            resourceInputs["replicasMatchingAsgName"] = state ? state.replicasMatchingAsgName : undefined;
            resourceInputs["shouldSpreadAcrossZones"] = state ? state.shouldSpreadAcrossZones : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["tenantId"] = state ? state.tenantId : undefined;
            resourceInputs["volumes"] = state ? state.volumes : undefined;
        } else {
            const args = argsOrState as DuploServiceArgs | undefined;
            if ((!args || args.dockerImage === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dockerImage'");
            }
            if ((!args || args.tenantId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'tenantId'");
            }
            resourceInputs["agentPlatform"] = args ? args.agentPlatform : undefined;
            resourceInputs["allocationTags"] = args ? args.allocationTags : undefined;
            resourceInputs["anyHostAllowed"] = args ? args.anyHostAllowed : undefined;
            resourceInputs["cloud"] = args ? args.cloud : undefined;
            resourceInputs["cloudCredsFromK8sServiceAccount"] = args ? args.cloudCredsFromK8sServiceAccount : undefined;
            resourceInputs["commands"] = args ? args.commands : undefined;
            resourceInputs["dockerImage"] = args ? args.dockerImage : undefined;
            resourceInputs["extraConfig"] = args ? args.extraConfig : undefined;
            resourceInputs["forceRecreateOnVolumesChange"] = args ? args.forceRecreateOnVolumesChange : undefined;
            resourceInputs["forceStatefulSet"] = args ? args.forceStatefulSet : undefined;
            resourceInputs["hpaSpecs"] = args ? args.hpaSpecs : undefined;
            resourceInputs["isDaemonset"] = args ? args.isDaemonset : undefined;
            resourceInputs["isUniqueK8sNodeRequired"] = args ? args.isUniqueK8sNodeRequired : undefined;
            resourceInputs["lbSyncedDeployment"] = args ? args.lbSyncedDeployment : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["otherDockerConfig"] = args ? args.otherDockerConfig : undefined;
            resourceInputs["otherDockerHostConfig"] = args ? args.otherDockerHostConfig : undefined;
            resourceInputs["replicaCollocationAllowed"] = args ? args.replicaCollocationAllowed : undefined;
            resourceInputs["replicas"] = args ? args.replicas : undefined;
            resourceInputs["replicasMatchingAsgName"] = args ? args.replicasMatchingAsgName : undefined;
            resourceInputs["shouldSpreadAcrossZones"] = args ? args.shouldSpreadAcrossZones : undefined;
            resourceInputs["tenantId"] = args ? args.tenantId : undefined;
            resourceInputs["volumes"] = args ? args.volumes : undefined;
            resourceInputs["domain"] = undefined /*out*/;
            resourceInputs["fqdn"] = undefined /*out*/;
            resourceInputs["fqdnEx"] = undefined /*out*/;
            resourceInputs["index"] = undefined /*out*/;
            resourceInputs["parentDomain"] = undefined /*out*/;
            resourceInputs["tags"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DuploService.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DuploService resources.
 */
export interface DuploServiceState {
    /**
     * The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
     * `7` : Linux container agent for Kubernetes
     */
    agentPlatform?: pulumi.Input<number>;
    allocationTags?: pulumi.Input<string>;
    /**
     * Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
     */
    anyHostAllowed?: pulumi.Input<boolean>;
    /**
     * The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
     * `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
     */
    cloud?: pulumi.Input<number>;
    /**
     * Whether or not the service gets it's cloud credentials from Kubernetes service account.
     */
    cloudCredsFromK8sServiceAccount?: pulumi.Input<boolean>;
    commands?: pulumi.Input<string>;
    /**
     * The docker image to use for the launched container(s).
     */
    dockerImage?: pulumi.Input<string>;
    /**
     * The service domain (whichever fqdnEx or fqdn which is non empty)
     */
    domain?: pulumi.Input<string>;
    extraConfig?: pulumi.Input<string>;
    /**
     * if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
     * the resource.
     */
    forceRecreateOnVolumesChange?: pulumi.Input<boolean>;
    /**
     * Whether or not to force a StatefulSet to be created.
     */
    forceStatefulSet?: pulumi.Input<boolean>;
    /**
     * The fully qualified domain associated with the service
     */
    fqdn?: pulumi.Input<string>;
    /**
     * External fully qualified domain associated with the service
     */
    fqdnEx?: pulumi.Input<string>;
    hpaSpecs?: pulumi.Input<string>;
    /**
     * The index of the service.
     */
    index?: pulumi.Input<number>;
    /**
     * Whether or not to enable DaemonSet.
     */
    isDaemonset?: pulumi.Input<boolean>;
    /**
     * Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
     */
    isUniqueK8sNodeRequired?: pulumi.Input<boolean>;
    lbSyncedDeployment?: pulumi.Input<boolean>;
    /**
     * The name of the service to create.
     */
    name?: pulumi.Input<string>;
    otherDockerConfig?: pulumi.Input<string>;
    otherDockerHostConfig?: pulumi.Input<string>;
    /**
     * The service's parent domain
     */
    parentDomain?: pulumi.Input<string>;
    /**
     * Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
     */
    replicaCollocationAllowed?: pulumi.Input<boolean>;
    /**
     * The number of container replicas to deploy.
     */
    replicas?: pulumi.Input<number>;
    replicasMatchingAsgName?: pulumi.Input<string>;
    /**
     * Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
     */
    shouldSpreadAcrossZones?: pulumi.Input<boolean>;
    tags?: pulumi.Input<pulumi.Input<inputs.DuploServiceTag>[]>;
    /**
     * The GUID of the tenant that the service will be created in.
     */
    tenantId?: pulumi.Input<string>;
    /**
     * Volumes to be attached to pod.
     */
    volumes?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DuploService resource.
 */
export interface DuploServiceArgs {
    /**
     * The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
     * `7` : Linux container agent for Kubernetes
     */
    agentPlatform?: pulumi.Input<number>;
    allocationTags?: pulumi.Input<string>;
    /**
     * Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
     */
    anyHostAllowed?: pulumi.Input<boolean>;
    /**
     * The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
     * `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
     */
    cloud?: pulumi.Input<number>;
    /**
     * Whether or not the service gets it's cloud credentials from Kubernetes service account.
     */
    cloudCredsFromK8sServiceAccount?: pulumi.Input<boolean>;
    commands?: pulumi.Input<string>;
    /**
     * The docker image to use for the launched container(s).
     */
    dockerImage: pulumi.Input<string>;
    extraConfig?: pulumi.Input<string>;
    /**
     * if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
     * the resource.
     */
    forceRecreateOnVolumesChange?: pulumi.Input<boolean>;
    /**
     * Whether or not to force a StatefulSet to be created.
     */
    forceStatefulSet?: pulumi.Input<boolean>;
    hpaSpecs?: pulumi.Input<string>;
    /**
     * Whether or not to enable DaemonSet.
     */
    isDaemonset?: pulumi.Input<boolean>;
    /**
     * Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
     */
    isUniqueK8sNodeRequired?: pulumi.Input<boolean>;
    lbSyncedDeployment?: pulumi.Input<boolean>;
    /**
     * The name of the service to create.
     */
    name?: pulumi.Input<string>;
    otherDockerConfig?: pulumi.Input<string>;
    otherDockerHostConfig?: pulumi.Input<string>;
    /**
     * Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
     */
    replicaCollocationAllowed?: pulumi.Input<boolean>;
    /**
     * The number of container replicas to deploy.
     */
    replicas?: pulumi.Input<number>;
    replicasMatchingAsgName?: pulumi.Input<string>;
    /**
     * Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
     */
    shouldSpreadAcrossZones?: pulumi.Input<boolean>;
    /**
     * The GUID of the tenant that the service will be created in.
     */
    tenantId: pulumi.Input<string>;
    /**
     * Volumes to be attached to pod.
     */
    volumes?: pulumi.Input<string>;
}
