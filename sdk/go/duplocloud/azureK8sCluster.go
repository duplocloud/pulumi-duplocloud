// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package duplocloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `AzureK8sCluster` manages an azure kubernetes cluster in Duplo.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			infra, err := duplocloud.NewInfrastructure(ctx, "infra", &duplocloud.InfrastructureArgs{
//				InfraName:           pulumi.String("tst-0206"),
//				AccountId:           pulumi.String("143ffc59-9394-4ec6-8f5a-c408a238be62"),
//				Cloud:               pulumi.Int(2),
//				Azcount:             pulumi.Int(2),
//				Region:              pulumi.String("West US 2"),
//				EnableK8Cluster:     pulumi.Bool(false),
//				AddressPrefix:       pulumi.String("10.50.0.0/16"),
//				SubnetCidr:          pulumi.Int(0),
//				SubnetName:          pulumi.String("sub01"),
//				SubnetAddressPrefix: pulumi.String("10.50.1.0/24"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = duplocloud.NewAzureK8sCluster(ctx, "cluster", &duplocloud.AzureK8sClusterArgs{
//				InfraName: infra.InfraName,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Example: Importing an existing Azure K8S Cluster
//
//   - *INFRA_NAME* is the infrastructure name
//
// #
//
// ```sh
// $ pulumi import duplocloud:index/azureK8sCluster:AzureK8sCluster cluster v2/admin/InfrastructureV2/*INFRA_NAME*
// ```
type AzureK8sCluster struct {
	pulumi.CustomResourceState

	// The name of the infrastructure.
	InfraName pulumi.StringOutput `pulumi:"infraName"`
	// Version of Kubernetes specified when creating the AKS managed cluster.
	KubernetesVersion pulumi.StringOutput `pulumi:"kubernetesVersion"`
	// The name of the aks. If not specified default name would be infra name
	Name pulumi.StringOutput `pulumi:"name"`
	// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
	NetworkPlugin pulumi.StringOutput `pulumi:"networkPlugin"`
	// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
	OutboundType pulumi.StringOutput `pulumi:"outboundType"`
	// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
	PrivateClusterEnabled pulumi.BoolPtrOutput `pulumi:"privateClusterEnabled"`
	// The name of the aks resource group.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// The size of the Virtual Machine.
	VmSize pulumi.StringOutput `pulumi:"vmSize"`
}

// NewAzureK8sCluster registers a new resource with the given unique name, arguments, and options.
func NewAzureK8sCluster(ctx *pulumi.Context,
	name string, args *AzureK8sClusterArgs, opts ...pulumi.ResourceOption) (*AzureK8sCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InfraName == nil {
		return nil, errors.New("invalid value for required argument 'InfraName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AzureK8sCluster
	err := ctx.RegisterResource("duplocloud:index/azureK8sCluster:AzureK8sCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAzureK8sCluster gets an existing AzureK8sCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAzureK8sCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AzureK8sClusterState, opts ...pulumi.ResourceOption) (*AzureK8sCluster, error) {
	var resource AzureK8sCluster
	err := ctx.ReadResource("duplocloud:index/azureK8sCluster:AzureK8sCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AzureK8sCluster resources.
type azureK8sClusterState struct {
	// The name of the infrastructure.
	InfraName *string `pulumi:"infraName"`
	// Version of Kubernetes specified when creating the AKS managed cluster.
	KubernetesVersion *string `pulumi:"kubernetesVersion"`
	// The name of the aks. If not specified default name would be infra name
	Name *string `pulumi:"name"`
	// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
	NetworkPlugin *string `pulumi:"networkPlugin"`
	// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
	OutboundType *string `pulumi:"outboundType"`
	// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
	PrivateClusterEnabled *bool `pulumi:"privateClusterEnabled"`
	// The name of the aks resource group.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// The size of the Virtual Machine.
	VmSize *string `pulumi:"vmSize"`
}

type AzureK8sClusterState struct {
	// The name of the infrastructure.
	InfraName pulumi.StringPtrInput
	// Version of Kubernetes specified when creating the AKS managed cluster.
	KubernetesVersion pulumi.StringPtrInput
	// The name of the aks. If not specified default name would be infra name
	Name pulumi.StringPtrInput
	// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
	NetworkPlugin pulumi.StringPtrInput
	// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
	OutboundType pulumi.StringPtrInput
	// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
	PrivateClusterEnabled pulumi.BoolPtrInput
	// The name of the aks resource group.
	ResourceGroupName pulumi.StringPtrInput
	// The size of the Virtual Machine.
	VmSize pulumi.StringPtrInput
}

func (AzureK8sClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*azureK8sClusterState)(nil)).Elem()
}

type azureK8sClusterArgs struct {
	// The name of the infrastructure.
	InfraName string `pulumi:"infraName"`
	// Version of Kubernetes specified when creating the AKS managed cluster.
	KubernetesVersion *string `pulumi:"kubernetesVersion"`
	// The name of the aks. If not specified default name would be infra name
	Name *string `pulumi:"name"`
	// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
	NetworkPlugin *string `pulumi:"networkPlugin"`
	// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
	OutboundType *string `pulumi:"outboundType"`
	// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
	PrivateClusterEnabled *bool `pulumi:"privateClusterEnabled"`
	// The name of the aks resource group.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// The size of the Virtual Machine.
	VmSize *string `pulumi:"vmSize"`
}

// The set of arguments for constructing a AzureK8sCluster resource.
type AzureK8sClusterArgs struct {
	// The name of the infrastructure.
	InfraName pulumi.StringInput
	// Version of Kubernetes specified when creating the AKS managed cluster.
	KubernetesVersion pulumi.StringPtrInput
	// The name of the aks. If not specified default name would be infra name
	Name pulumi.StringPtrInput
	// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
	NetworkPlugin pulumi.StringPtrInput
	// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
	OutboundType pulumi.StringPtrInput
	// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
	PrivateClusterEnabled pulumi.BoolPtrInput
	// The name of the aks resource group.
	ResourceGroupName pulumi.StringPtrInput
	// The size of the Virtual Machine.
	VmSize pulumi.StringPtrInput
}

func (AzureK8sClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*azureK8sClusterArgs)(nil)).Elem()
}

type AzureK8sClusterInput interface {
	pulumi.Input

	ToAzureK8sClusterOutput() AzureK8sClusterOutput
	ToAzureK8sClusterOutputWithContext(ctx context.Context) AzureK8sClusterOutput
}

func (*AzureK8sCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureK8sCluster)(nil)).Elem()
}

func (i *AzureK8sCluster) ToAzureK8sClusterOutput() AzureK8sClusterOutput {
	return i.ToAzureK8sClusterOutputWithContext(context.Background())
}

func (i *AzureK8sCluster) ToAzureK8sClusterOutputWithContext(ctx context.Context) AzureK8sClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureK8sClusterOutput)
}

// AzureK8sClusterArrayInput is an input type that accepts AzureK8sClusterArray and AzureK8sClusterArrayOutput values.
// You can construct a concrete instance of `AzureK8sClusterArrayInput` via:
//
//	AzureK8sClusterArray{ AzureK8sClusterArgs{...} }
type AzureK8sClusterArrayInput interface {
	pulumi.Input

	ToAzureK8sClusterArrayOutput() AzureK8sClusterArrayOutput
	ToAzureK8sClusterArrayOutputWithContext(context.Context) AzureK8sClusterArrayOutput
}

type AzureK8sClusterArray []AzureK8sClusterInput

func (AzureK8sClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AzureK8sCluster)(nil)).Elem()
}

func (i AzureK8sClusterArray) ToAzureK8sClusterArrayOutput() AzureK8sClusterArrayOutput {
	return i.ToAzureK8sClusterArrayOutputWithContext(context.Background())
}

func (i AzureK8sClusterArray) ToAzureK8sClusterArrayOutputWithContext(ctx context.Context) AzureK8sClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureK8sClusterArrayOutput)
}

// AzureK8sClusterMapInput is an input type that accepts AzureK8sClusterMap and AzureK8sClusterMapOutput values.
// You can construct a concrete instance of `AzureK8sClusterMapInput` via:
//
//	AzureK8sClusterMap{ "key": AzureK8sClusterArgs{...} }
type AzureK8sClusterMapInput interface {
	pulumi.Input

	ToAzureK8sClusterMapOutput() AzureK8sClusterMapOutput
	ToAzureK8sClusterMapOutputWithContext(context.Context) AzureK8sClusterMapOutput
}

type AzureK8sClusterMap map[string]AzureK8sClusterInput

func (AzureK8sClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AzureK8sCluster)(nil)).Elem()
}

func (i AzureK8sClusterMap) ToAzureK8sClusterMapOutput() AzureK8sClusterMapOutput {
	return i.ToAzureK8sClusterMapOutputWithContext(context.Background())
}

func (i AzureK8sClusterMap) ToAzureK8sClusterMapOutputWithContext(ctx context.Context) AzureK8sClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureK8sClusterMapOutput)
}

type AzureK8sClusterOutput struct{ *pulumi.OutputState }

func (AzureK8sClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureK8sCluster)(nil)).Elem()
}

func (o AzureK8sClusterOutput) ToAzureK8sClusterOutput() AzureK8sClusterOutput {
	return o
}

func (o AzureK8sClusterOutput) ToAzureK8sClusterOutputWithContext(ctx context.Context) AzureK8sClusterOutput {
	return o
}

// The name of the infrastructure.
func (o AzureK8sClusterOutput) InfraName() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.InfraName }).(pulumi.StringOutput)
}

// Version of Kubernetes specified when creating the AKS managed cluster.
func (o AzureK8sClusterOutput) KubernetesVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.KubernetesVersion }).(pulumi.StringOutput)
}

// The name of the aks. If not specified default name would be infra name
func (o AzureK8sClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Network plugin to use for networking. Valid values are: `azure` and `kubenet`.
func (o AzureK8sClusterOutput) NetworkPlugin() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.NetworkPlugin }).(pulumi.StringOutput)
}

// The outbound (egress) routing method which should be used for this Kubernetes Cluster. Valid values are: `loadBalancer` and `userDefinedRouting`.
func (o AzureK8sClusterOutput) OutboundType() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.OutboundType }).(pulumi.StringOutput)
}

// Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`.
func (o AzureK8sClusterOutput) PrivateClusterEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.BoolPtrOutput { return v.PrivateClusterEnabled }).(pulumi.BoolPtrOutput)
}

// The name of the aks resource group.
func (o AzureK8sClusterOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// The size of the Virtual Machine.
func (o AzureK8sClusterOutput) VmSize() pulumi.StringOutput {
	return o.ApplyT(func(v *AzureK8sCluster) pulumi.StringOutput { return v.VmSize }).(pulumi.StringOutput)
}

type AzureK8sClusterArrayOutput struct{ *pulumi.OutputState }

func (AzureK8sClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AzureK8sCluster)(nil)).Elem()
}

func (o AzureK8sClusterArrayOutput) ToAzureK8sClusterArrayOutput() AzureK8sClusterArrayOutput {
	return o
}

func (o AzureK8sClusterArrayOutput) ToAzureK8sClusterArrayOutputWithContext(ctx context.Context) AzureK8sClusterArrayOutput {
	return o
}

func (o AzureK8sClusterArrayOutput) Index(i pulumi.IntInput) AzureK8sClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AzureK8sCluster {
		return vs[0].([]*AzureK8sCluster)[vs[1].(int)]
	}).(AzureK8sClusterOutput)
}

type AzureK8sClusterMapOutput struct{ *pulumi.OutputState }

func (AzureK8sClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AzureK8sCluster)(nil)).Elem()
}

func (o AzureK8sClusterMapOutput) ToAzureK8sClusterMapOutput() AzureK8sClusterMapOutput {
	return o
}

func (o AzureK8sClusterMapOutput) ToAzureK8sClusterMapOutputWithContext(ctx context.Context) AzureK8sClusterMapOutput {
	return o
}

func (o AzureK8sClusterMapOutput) MapIndex(k pulumi.StringInput) AzureK8sClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AzureK8sCluster {
		return vs[0].(map[string]*AzureK8sCluster)[vs[1].(string)]
	}).(AzureK8sClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AzureK8sClusterInput)(nil)).Elem(), &AzureK8sCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*AzureK8sClusterArrayInput)(nil)).Elem(), AzureK8sClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AzureK8sClusterMapInput)(nil)).Elem(), AzureK8sClusterMap{})
	pulumi.RegisterOutputType(AzureK8sClusterOutput{})
	pulumi.RegisterOutputType(AzureK8sClusterArrayOutput{})
	pulumi.RegisterOutputType(AzureK8sClusterMapOutput{})
}
