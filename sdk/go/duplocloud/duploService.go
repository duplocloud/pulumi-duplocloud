// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package duplocloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Deploy NGINX service using DuploCloud Platform's native container agent.
//
// ```go
// package main
//
// import (
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Before creating an NGINX service, you must first set up the infrastructure and tenant. Below is the resource for creating the infrastructure.
//			infra, err := duplocloud.NewInfrastructure(ctx, "infra", &duplocloud.InfrastructureArgs{
//				InfraName:       pulumi.String("dev"),
//				Cloud:           pulumi.Int(0),
//				Region:          pulumi.String("us-east-1"),
//				EnableK8Cluster: pulumi.Bool(false),
//				AddressPrefix:   pulumi.String("10.13.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			// Use the infrastructure name as the 'plan_id' from the 'duplocloud_infrastructure' resource while creating tenant.
//			tenant, err := duplocloud.NewTenant(ctx, "tenant", &duplocloud.TenantArgs{
//				AccountName: pulumi.String("dev"),
//				PlanId:      infra.InfraName,
//			})
//			if err != nil {
//				return err
//			}
//			// You will need a DuploCloud host to launch the Duplo service, so create a host using following resource configuration.
//			image := duplocloud.GetNativeHostImageOutput(ctx, duplocloud.GetNativeHostImageOutputArgs{
//				TenantId:     tenant.TenantId,
//				IsKubernetes: pulumi.Bool(false),
//			}, nil)
//			_, err = duplocloud.NewAwsHost(ctx, "host", &duplocloud.AwsHostArgs{
//				TenantId:     tenant.TenantId,
//				FriendlyName: pulumi.String("host01"),
//				ImageId: pulumi.String(image.ApplyT(func(image duplocloud.GetNativeHostImageResult) (*string, error) {
//					return &image.ImageId, nil
//				}).(pulumi.StringPtrOutput)),
//				Capacity:      pulumi.String("t3a.small"),
//				AgentPlatform: pulumi.Int(0),
//				Zone:          pulumi.Int(0),
//				UserAccount:   tenant.AccountName,
//				KeypairType:   pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = duplocloud.NewDuploService(ctx, "myservice", &duplocloud.DuploServiceArgs{
//				TenantId:      tenant.TenantId,
//				Name:          pulumi.String("myservice"),
//				AgentPlatform: pulumi.Int(0),
//				DockerImage:   pulumi.String("nginx:latest"),
//				Replicas:      pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy NGINX service inside the 'nonprod' tenant using DuploCloud Platform's native container agent with host networking and the environment variables - NGINX_HOST and NGINX_PORT
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'nonprod' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("nonprod"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// Create a data source to retrieve the Machine Image ID to be used by the host
//			image, err := duplocloud.GetNativeHostImage(ctx, &duplocloud.GetNativeHostImageArgs{
//				TenantId:     tenant.Id,
//				IsKubernetes: pulumi.BoolRef(false),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = duplocloud.NewAwsHost(ctx, "host", &duplocloud.AwsHostArgs{
//				TenantId:      pulumi.String(tenant.Id),
//				FriendlyName:  pulumi.String("host01"),
//				ImageId:       pulumi.String(image.ImageId),
//				Capacity:      pulumi.String("t3a.small"),
//				AgentPlatform: pulumi.Int(0),
//				Zone:          pulumi.Int(0),
//				UserAccount:   pulumi.String(tenant.Name),
//				KeypairType:   pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"NGINX_HOST": "foo",
//				"NGINX_PORT": "8080",
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			tmpJSON1, err := json.Marshal(map[string]interface{}{
//				"NetworkMode": "host",
//				"CapAdd": []string{
//					"NET_ADMIN",
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json1 := string(tmpJSON1)
//			// Create the DuploCloud service
//			_, err = duplocloud.NewDuploService(ctx, "myservice", &duplocloud.DuploServiceArgs{
//				TenantId:              pulumi.String(tenant.Id),
//				Name:                  pulumi.String("myservice"),
//				AgentPlatform:         pulumi.Int(0),
//				DockerImage:           pulumi.String("nginx:latest"),
//				Replicas:              pulumi.Int(1),
//				ExtraConfig:           pulumi.String(json0),
//				OtherDockerHostConfig: pulumi.String(json1),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy NGINX service named nginx inside the 'dev' tenant and set the resource requests and limits. Set cpu requests and limits to 200m and 300m respectively and set memory requests and limits to 100Mi and 300Mi respectively
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("dev"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"Resources": map[string]interface{}{
//					"requests": map[string]interface{}{
//						"cpu":    "200m",
//						"memory": "100Mi",
//					},
//					"limits": map[string]interface{}{
//						"cpu":    "300m",
//						"memory": "300Mi",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			// Assuming that a host already exists in the tenant, create a service
//			_, err = duplocloud.NewDuploService(ctx, "nginx", &duplocloud.DuploServiceArgs{
//				TenantId:          pulumi.String(tenant.Id),
//				Name:              pulumi.String("nginx"),
//				AgentPlatform:     pulumi.Int(7),
//				DockerImage:       pulumi.String("nginx:latest"),
//				Replicas:          pulumi.Int(1),
//				OtherDockerConfig: pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy an Nginx service named nginx inside the prod tenant and mount these environment variables from the kubernetes secrets - 1. FOO: bar 2. PING: pong
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'prod' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("prod"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"FOO":  "bar",
//				"PING": "pong",
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			// Create a secret with the env vars values 1. FOO: bar 2. PING: pong if it does not exist
//			nginx, err := duplocloud.NewK8Secret(ctx, "nginx", &duplocloud.K8SecretArgs{
//				TenantId:   pulumi.String(tenant.Id),
//				SecretName: pulumi.String("nginx-secret"),
//				SecretType: pulumi.String("Opaque"),
//				SecretData: pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			// Assuming that a host exists in the tenant.
//			_, err = duplocloud.NewDuploService(ctx, "nginx", &duplocloud.DuploServiceArgs{
//				TenantId:      pulumi.String(tenant.Id),
//				Name:          pulumi.String("nginx"),
//				AgentPlatform: pulumi.Int(7),
//				DockerImage:   pulumi.String("nginx:latest"),
//				Replicas:      pulumi.Int(1),
//				OtherDockerConfig: nginx.SecretName.ApplyT(func(secretName string) (pulumi.String, error) {
//					var _zero pulumi.String
//					tmpJSON1, err := json.Marshal(map[string]interface{}{
//						"EnvFrom": []map[string]interface{}{
//							map[string]interface{}{
//								"secretRef": map[string]interface{}{
//									"name": secretName,
//								},
//							},
//						},
//					})
//					if err != nil {
//						return _zero, err
//					}
//					json1 := string(tmpJSON1)
//					return pulumi.String(json1), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy an Nginx service named nginx inside the dev tenant, and mount these environment variables from the kubernetes configmap - 1. FOO: bar 2. PING: pong
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("dev"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"FOO":  "bar",
//				"PING": "pong",
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			// Create a configmap with the env vars values 1. FOO: bar 2. PING: pong if it does not exists
//			nginx, err := duplocloud.NewK8ConfigMap(ctx, "nginx", &duplocloud.K8ConfigMapArgs{
//				TenantId: pulumi.String(tenant.Id),
//				Name:     pulumi.String("nginx-cm"),
//				Data:     pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			// Ensure that the host is also created in the tenant.
//			_, err = duplocloud.NewDuploService(ctx, "nginx", &duplocloud.DuploServiceArgs{
//				TenantId:      pulumi.String(tenant.Id),
//				Name:          pulumi.String("nginx"),
//				AgentPlatform: pulumi.Int(7),
//				DockerImage:   pulumi.String("nginx:latest"),
//				Replicas:      pulumi.Int(1),
//				OtherDockerConfig: nginx.Name.ApplyT(func(name string) (pulumi.String, error) {
//					var _zero pulumi.String
//					tmpJSON1, err := json.Marshal(map[string]interface{}{
//						"EnvFrom": []map[string]interface{}{
//							map[string]interface{}{
//								"configMapRef": map[string]interface{}{
//									"name": name,
//								},
//							},
//						},
//					})
//					if err != nil {
//						return _zero, err
//					}
//					json1 := string(tmpJSON1)
//					return pulumi.String(json1), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy an Nginx service named nginx inside the dev tenant, and set the replica count to 5
//
// ```go
// package main
//
// import (
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("dev"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			// Ensure that the host is also created in the tenant.
//			_, err = duplocloud.NewDuploService(ctx, "nginx", &duplocloud.DuploServiceArgs{
//				TenantId:      pulumi.String(tenant.Id),
//				Name:          pulumi.String("nginx"),
//				AgentPlatform: pulumi.Int(7),
//				DockerImage:   pulumi.String("nginx:latest"),
//				Replicas:      pulumi.Int(5),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Deploy an Nginx service named nginx with liveliness probe. Create it inside the dev tenant which already exists.
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Ensure the 'dev' tenant is already created before deploying the Nginx duplo service.
//			tenant, err := duplocloud.LookupTenant(ctx, &duplocloud.LookupTenantArgs{
//				Name: pulumi.StringRef("dev"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"LivenessProbe": map[string]interface{}{
//					"initialDelaySeconds": 10,
//					"periodSeconds":       30,
//					"successThreshold":    1,
//					"httpGet": map[string]interface{}{
//						"path": "/health",
//						"port": 80,
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			// Assuming a host already exists in the tenant, create the duplo service
//			_, err = duplocloud.NewDuploService(ctx, "nginx", &duplocloud.DuploServiceArgs{
//				TenantId:          pulumi.String(tenant.Id),
//				Name:              pulumi.String("nginx"),
//				AgentPlatform:     pulumi.Int(7),
//				DockerImage:       pulumi.String("nginx:latest"),
//				Replicas:          pulumi.Int(1),
//				OtherDockerConfig: pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Example: Importing an existing service
//
//   - *TENANT_ID* is the tenant GUID
//
//   - *NAME* is the name of the service
//
// #
//
// ```sh
// $ pulumi import duplocloud:index/duploService:DuploService myservice v2/subscriptions/*TENANT_ID*/ReplicationControllerApiV2/*NAME*
// ```
type DuploService struct {
	pulumi.CustomResourceState

	// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
	// `7` : Linux container agent for Kubernetes
	AgentPlatform  pulumi.IntPtrOutput    `pulumi:"agentPlatform"`
	AllocationTags pulumi.StringPtrOutput `pulumi:"allocationTags"`
	// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
	AnyHostAllowed pulumi.BoolPtrOutput `pulumi:"anyHostAllowed"`
	// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
	// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
	Cloud pulumi.IntPtrOutput `pulumi:"cloud"`
	// Whether or not the service gets it's cloud credentials from Kubernetes service account.
	CloudCredsFromK8sServiceAccount pulumi.BoolPtrOutput   `pulumi:"cloudCredsFromK8sServiceAccount"`
	Commands                        pulumi.StringPtrOutput `pulumi:"commands"`
	// The docker image to use for the launched container(s).
	DockerImage pulumi.StringOutput `pulumi:"dockerImage"`
	// The service domain (whichever fqdnEx or fqdn which is non empty)
	Domain      pulumi.StringOutput    `pulumi:"domain"`
	ExtraConfig pulumi.StringPtrOutput `pulumi:"extraConfig"`
	// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
	// the resource.
	ForceRecreateOnVolumesChange pulumi.BoolPtrOutput `pulumi:"forceRecreateOnVolumesChange"`
	// Whether or not to force a StatefulSet to be created.
	ForceStatefulSet pulumi.BoolPtrOutput `pulumi:"forceStatefulSet"`
	// The fully qualified domain associated with the service
	Fqdn pulumi.StringOutput `pulumi:"fqdn"`
	// External fully qualified domain associated with the service
	FqdnEx   pulumi.StringOutput `pulumi:"fqdnEx"`
	HpaSpecs pulumi.StringOutput `pulumi:"hpaSpecs"`
	// The index of the service.
	Index pulumi.IntOutput `pulumi:"index"`
	// Whether or not to enable DaemonSet.
	IsDaemonset pulumi.BoolPtrOutput `pulumi:"isDaemonset"`
	// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
	IsUniqueK8sNodeRequired pulumi.BoolPtrOutput `pulumi:"isUniqueK8sNodeRequired"`
	LbSyncedDeployment      pulumi.BoolPtrOutput `pulumi:"lbSyncedDeployment"`
	// The name of the service to create.
	Name                  pulumi.StringOutput    `pulumi:"name"`
	OtherDockerConfig     pulumi.StringOutput    `pulumi:"otherDockerConfig"`
	OtherDockerHostConfig pulumi.StringPtrOutput `pulumi:"otherDockerHostConfig"`
	// The service's parent domain
	ParentDomain pulumi.StringOutput `pulumi:"parentDomain"`
	// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
	ReplicaCollocationAllowed pulumi.BoolOutput `pulumi:"replicaCollocationAllowed"`
	// The number of container replicas to deploy.
	Replicas                pulumi.IntPtrOutput    `pulumi:"replicas"`
	ReplicasMatchingAsgName pulumi.StringPtrOutput `pulumi:"replicasMatchingAsgName"`
	// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
	ShouldSpreadAcrossZones pulumi.BoolPtrOutput       `pulumi:"shouldSpreadAcrossZones"`
	Tags                    DuploServiceTagArrayOutput `pulumi:"tags"`
	// The GUID of the tenant that the service will be created in.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
	// Volumes to be attached to pod.
	Volumes pulumi.StringPtrOutput `pulumi:"volumes"`
}

// NewDuploService registers a new resource with the given unique name, arguments, and options.
func NewDuploService(ctx *pulumi.Context,
	name string, args *DuploServiceArgs, opts ...pulumi.ResourceOption) (*DuploService, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DockerImage == nil {
		return nil, errors.New("invalid value for required argument 'DockerImage'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DuploService
	err := ctx.RegisterResource("duplocloud:index/duploService:DuploService", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDuploService gets an existing DuploService resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDuploService(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DuploServiceState, opts ...pulumi.ResourceOption) (*DuploService, error) {
	var resource DuploService
	err := ctx.ReadResource("duplocloud:index/duploService:DuploService", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DuploService resources.
type duploServiceState struct {
	// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
	// `7` : Linux container agent for Kubernetes
	AgentPlatform  *int    `pulumi:"agentPlatform"`
	AllocationTags *string `pulumi:"allocationTags"`
	// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
	AnyHostAllowed *bool `pulumi:"anyHostAllowed"`
	// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
	// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
	Cloud *int `pulumi:"cloud"`
	// Whether or not the service gets it's cloud credentials from Kubernetes service account.
	CloudCredsFromK8sServiceAccount *bool   `pulumi:"cloudCredsFromK8sServiceAccount"`
	Commands                        *string `pulumi:"commands"`
	// The docker image to use for the launched container(s).
	DockerImage *string `pulumi:"dockerImage"`
	// The service domain (whichever fqdnEx or fqdn which is non empty)
	Domain      *string `pulumi:"domain"`
	ExtraConfig *string `pulumi:"extraConfig"`
	// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
	// the resource.
	ForceRecreateOnVolumesChange *bool `pulumi:"forceRecreateOnVolumesChange"`
	// Whether or not to force a StatefulSet to be created.
	ForceStatefulSet *bool `pulumi:"forceStatefulSet"`
	// The fully qualified domain associated with the service
	Fqdn *string `pulumi:"fqdn"`
	// External fully qualified domain associated with the service
	FqdnEx   *string `pulumi:"fqdnEx"`
	HpaSpecs *string `pulumi:"hpaSpecs"`
	// The index of the service.
	Index *int `pulumi:"index"`
	// Whether or not to enable DaemonSet.
	IsDaemonset *bool `pulumi:"isDaemonset"`
	// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
	IsUniqueK8sNodeRequired *bool `pulumi:"isUniqueK8sNodeRequired"`
	LbSyncedDeployment      *bool `pulumi:"lbSyncedDeployment"`
	// The name of the service to create.
	Name                  *string `pulumi:"name"`
	OtherDockerConfig     *string `pulumi:"otherDockerConfig"`
	OtherDockerHostConfig *string `pulumi:"otherDockerHostConfig"`
	// The service's parent domain
	ParentDomain *string `pulumi:"parentDomain"`
	// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
	ReplicaCollocationAllowed *bool `pulumi:"replicaCollocationAllowed"`
	// The number of container replicas to deploy.
	Replicas                *int    `pulumi:"replicas"`
	ReplicasMatchingAsgName *string `pulumi:"replicasMatchingAsgName"`
	// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
	ShouldSpreadAcrossZones *bool             `pulumi:"shouldSpreadAcrossZones"`
	Tags                    []DuploServiceTag `pulumi:"tags"`
	// The GUID of the tenant that the service will be created in.
	TenantId *string `pulumi:"tenantId"`
	// Volumes to be attached to pod.
	Volumes *string `pulumi:"volumes"`
}

type DuploServiceState struct {
	// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
	// `7` : Linux container agent for Kubernetes
	AgentPlatform  pulumi.IntPtrInput
	AllocationTags pulumi.StringPtrInput
	// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
	AnyHostAllowed pulumi.BoolPtrInput
	// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
	// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
	Cloud pulumi.IntPtrInput
	// Whether or not the service gets it's cloud credentials from Kubernetes service account.
	CloudCredsFromK8sServiceAccount pulumi.BoolPtrInput
	Commands                        pulumi.StringPtrInput
	// The docker image to use for the launched container(s).
	DockerImage pulumi.StringPtrInput
	// The service domain (whichever fqdnEx or fqdn which is non empty)
	Domain      pulumi.StringPtrInput
	ExtraConfig pulumi.StringPtrInput
	// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
	// the resource.
	ForceRecreateOnVolumesChange pulumi.BoolPtrInput
	// Whether or not to force a StatefulSet to be created.
	ForceStatefulSet pulumi.BoolPtrInput
	// The fully qualified domain associated with the service
	Fqdn pulumi.StringPtrInput
	// External fully qualified domain associated with the service
	FqdnEx   pulumi.StringPtrInput
	HpaSpecs pulumi.StringPtrInput
	// The index of the service.
	Index pulumi.IntPtrInput
	// Whether or not to enable DaemonSet.
	IsDaemonset pulumi.BoolPtrInput
	// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
	IsUniqueK8sNodeRequired pulumi.BoolPtrInput
	LbSyncedDeployment      pulumi.BoolPtrInput
	// The name of the service to create.
	Name                  pulumi.StringPtrInput
	OtherDockerConfig     pulumi.StringPtrInput
	OtherDockerHostConfig pulumi.StringPtrInput
	// The service's parent domain
	ParentDomain pulumi.StringPtrInput
	// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
	ReplicaCollocationAllowed pulumi.BoolPtrInput
	// The number of container replicas to deploy.
	Replicas                pulumi.IntPtrInput
	ReplicasMatchingAsgName pulumi.StringPtrInput
	// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
	ShouldSpreadAcrossZones pulumi.BoolPtrInput
	Tags                    DuploServiceTagArrayInput
	// The GUID of the tenant that the service will be created in.
	TenantId pulumi.StringPtrInput
	// Volumes to be attached to pod.
	Volumes pulumi.StringPtrInput
}

func (DuploServiceState) ElementType() reflect.Type {
	return reflect.TypeOf((*duploServiceState)(nil)).Elem()
}

type duploServiceArgs struct {
	// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
	// `7` : Linux container agent for Kubernetes
	AgentPlatform  *int    `pulumi:"agentPlatform"`
	AllocationTags *string `pulumi:"allocationTags"`
	// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
	AnyHostAllowed *bool `pulumi:"anyHostAllowed"`
	// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
	// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
	Cloud *int `pulumi:"cloud"`
	// Whether or not the service gets it's cloud credentials from Kubernetes service account.
	CloudCredsFromK8sServiceAccount *bool   `pulumi:"cloudCredsFromK8sServiceAccount"`
	Commands                        *string `pulumi:"commands"`
	// The docker image to use for the launched container(s).
	DockerImage string  `pulumi:"dockerImage"`
	ExtraConfig *string `pulumi:"extraConfig"`
	// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
	// the resource.
	ForceRecreateOnVolumesChange *bool `pulumi:"forceRecreateOnVolumesChange"`
	// Whether or not to force a StatefulSet to be created.
	ForceStatefulSet *bool   `pulumi:"forceStatefulSet"`
	HpaSpecs         *string `pulumi:"hpaSpecs"`
	// Whether or not to enable DaemonSet.
	IsDaemonset *bool `pulumi:"isDaemonset"`
	// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
	IsUniqueK8sNodeRequired *bool `pulumi:"isUniqueK8sNodeRequired"`
	LbSyncedDeployment      *bool `pulumi:"lbSyncedDeployment"`
	// The name of the service to create.
	Name                  *string `pulumi:"name"`
	OtherDockerConfig     *string `pulumi:"otherDockerConfig"`
	OtherDockerHostConfig *string `pulumi:"otherDockerHostConfig"`
	// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
	ReplicaCollocationAllowed *bool `pulumi:"replicaCollocationAllowed"`
	// The number of container replicas to deploy.
	Replicas                *int    `pulumi:"replicas"`
	ReplicasMatchingAsgName *string `pulumi:"replicasMatchingAsgName"`
	// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
	ShouldSpreadAcrossZones *bool `pulumi:"shouldSpreadAcrossZones"`
	// The GUID of the tenant that the service will be created in.
	TenantId string `pulumi:"tenantId"`
	// Volumes to be attached to pod.
	Volumes *string `pulumi:"volumes"`
}

// The set of arguments for constructing a DuploService resource.
type DuploServiceArgs struct {
	// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
	// `7` : Linux container agent for Kubernetes
	AgentPlatform  pulumi.IntPtrInput
	AllocationTags pulumi.StringPtrInput
	// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
	AnyHostAllowed pulumi.BoolPtrInput
	// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
	// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
	Cloud pulumi.IntPtrInput
	// Whether or not the service gets it's cloud credentials from Kubernetes service account.
	CloudCredsFromK8sServiceAccount pulumi.BoolPtrInput
	Commands                        pulumi.StringPtrInput
	// The docker image to use for the launched container(s).
	DockerImage pulumi.StringInput
	ExtraConfig pulumi.StringPtrInput
	// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
	// the resource.
	ForceRecreateOnVolumesChange pulumi.BoolPtrInput
	// Whether or not to force a StatefulSet to be created.
	ForceStatefulSet pulumi.BoolPtrInput
	HpaSpecs         pulumi.StringPtrInput
	// Whether or not to enable DaemonSet.
	IsDaemonset pulumi.BoolPtrInput
	// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
	IsUniqueK8sNodeRequired pulumi.BoolPtrInput
	LbSyncedDeployment      pulumi.BoolPtrInput
	// The name of the service to create.
	Name                  pulumi.StringPtrInput
	OtherDockerConfig     pulumi.StringPtrInput
	OtherDockerHostConfig pulumi.StringPtrInput
	// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
	ReplicaCollocationAllowed pulumi.BoolPtrInput
	// The number of container replicas to deploy.
	Replicas                pulumi.IntPtrInput
	ReplicasMatchingAsgName pulumi.StringPtrInput
	// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
	ShouldSpreadAcrossZones pulumi.BoolPtrInput
	// The GUID of the tenant that the service will be created in.
	TenantId pulumi.StringInput
	// Volumes to be attached to pod.
	Volumes pulumi.StringPtrInput
}

func (DuploServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*duploServiceArgs)(nil)).Elem()
}

type DuploServiceInput interface {
	pulumi.Input

	ToDuploServiceOutput() DuploServiceOutput
	ToDuploServiceOutputWithContext(ctx context.Context) DuploServiceOutput
}

func (*DuploService) ElementType() reflect.Type {
	return reflect.TypeOf((**DuploService)(nil)).Elem()
}

func (i *DuploService) ToDuploServiceOutput() DuploServiceOutput {
	return i.ToDuploServiceOutputWithContext(context.Background())
}

func (i *DuploService) ToDuploServiceOutputWithContext(ctx context.Context) DuploServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DuploServiceOutput)
}

// DuploServiceArrayInput is an input type that accepts DuploServiceArray and DuploServiceArrayOutput values.
// You can construct a concrete instance of `DuploServiceArrayInput` via:
//
//	DuploServiceArray{ DuploServiceArgs{...} }
type DuploServiceArrayInput interface {
	pulumi.Input

	ToDuploServiceArrayOutput() DuploServiceArrayOutput
	ToDuploServiceArrayOutputWithContext(context.Context) DuploServiceArrayOutput
}

type DuploServiceArray []DuploServiceInput

func (DuploServiceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DuploService)(nil)).Elem()
}

func (i DuploServiceArray) ToDuploServiceArrayOutput() DuploServiceArrayOutput {
	return i.ToDuploServiceArrayOutputWithContext(context.Background())
}

func (i DuploServiceArray) ToDuploServiceArrayOutputWithContext(ctx context.Context) DuploServiceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DuploServiceArrayOutput)
}

// DuploServiceMapInput is an input type that accepts DuploServiceMap and DuploServiceMapOutput values.
// You can construct a concrete instance of `DuploServiceMapInput` via:
//
//	DuploServiceMap{ "key": DuploServiceArgs{...} }
type DuploServiceMapInput interface {
	pulumi.Input

	ToDuploServiceMapOutput() DuploServiceMapOutput
	ToDuploServiceMapOutputWithContext(context.Context) DuploServiceMapOutput
}

type DuploServiceMap map[string]DuploServiceInput

func (DuploServiceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DuploService)(nil)).Elem()
}

func (i DuploServiceMap) ToDuploServiceMapOutput() DuploServiceMapOutput {
	return i.ToDuploServiceMapOutputWithContext(context.Background())
}

func (i DuploServiceMap) ToDuploServiceMapOutputWithContext(ctx context.Context) DuploServiceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DuploServiceMapOutput)
}

type DuploServiceOutput struct{ *pulumi.OutputState }

func (DuploServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DuploService)(nil)).Elem()
}

func (o DuploServiceOutput) ToDuploServiceOutput() DuploServiceOutput {
	return o
}

func (o DuploServiceOutput) ToDuploServiceOutputWithContext(ctx context.Context) DuploServiceOutput {
	return o
}

// The numeric ID of the container agent to use for deployment. Should be one of: - `0` : Duplo Native container agent -
// `7` : Linux container agent for Kubernetes
func (o DuploServiceOutput) AgentPlatform() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.IntPtrOutput { return v.AgentPlatform }).(pulumi.IntPtrOutput)
}

func (o DuploServiceOutput) AllocationTags() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.AllocationTags }).(pulumi.StringPtrOutput)
}

// Whether or not the service can run on hosts in other tenants (within the the same plan as the current tenant).
func (o DuploServiceOutput) AnyHostAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.AnyHostAllowed }).(pulumi.BoolPtrOutput)
}

// The numeric ID of the cloud provider to launch the service in. Should be one of: - `0` : AWS (Default) - `1` : Oracle -
// `2` : Azure - `3` : Google - `4` : Byoh - `5` : Unknown - `6` : DigitalOcean - `10` : OnPrem
func (o DuploServiceOutput) Cloud() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.IntPtrOutput { return v.Cloud }).(pulumi.IntPtrOutput)
}

// Whether or not the service gets it's cloud credentials from Kubernetes service account.
func (o DuploServiceOutput) CloudCredsFromK8sServiceAccount() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.CloudCredsFromK8sServiceAccount }).(pulumi.BoolPtrOutput)
}

func (o DuploServiceOutput) Commands() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.Commands }).(pulumi.StringPtrOutput)
}

// The docker image to use for the launched container(s).
func (o DuploServiceOutput) DockerImage() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.DockerImage }).(pulumi.StringOutput)
}

// The service domain (whichever fqdnEx or fqdn which is non empty)
func (o DuploServiceOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.Domain }).(pulumi.StringOutput)
}

func (o DuploServiceOutput) ExtraConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.ExtraConfig }).(pulumi.StringPtrOutput)
}

// if 'force_recreate_on_volumes_change=true' and any changing to Volumes, will results in forceNew and hence recreating
// the resource.
func (o DuploServiceOutput) ForceRecreateOnVolumesChange() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.ForceRecreateOnVolumesChange }).(pulumi.BoolPtrOutput)
}

// Whether or not to force a StatefulSet to be created.
func (o DuploServiceOutput) ForceStatefulSet() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.ForceStatefulSet }).(pulumi.BoolPtrOutput)
}

// The fully qualified domain associated with the service
func (o DuploServiceOutput) Fqdn() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.Fqdn }).(pulumi.StringOutput)
}

// External fully qualified domain associated with the service
func (o DuploServiceOutput) FqdnEx() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.FqdnEx }).(pulumi.StringOutput)
}

func (o DuploServiceOutput) HpaSpecs() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.HpaSpecs }).(pulumi.StringOutput)
}

// The index of the service.
func (o DuploServiceOutput) Index() pulumi.IntOutput {
	return o.ApplyT(func(v *DuploService) pulumi.IntOutput { return v.Index }).(pulumi.IntOutput)
}

// Whether or not to enable DaemonSet.
func (o DuploServiceOutput) IsDaemonset() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.IsDaemonset }).(pulumi.BoolPtrOutput)
}

// Whether or not the replicas must be scheduled on separate Kubernetes nodes. Only supported on Kubernetes.
func (o DuploServiceOutput) IsUniqueK8sNodeRequired() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.IsUniqueK8sNodeRequired }).(pulumi.BoolPtrOutput)
}

func (o DuploServiceOutput) LbSyncedDeployment() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.LbSyncedDeployment }).(pulumi.BoolPtrOutput)
}

// The name of the service to create.
func (o DuploServiceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o DuploServiceOutput) OtherDockerConfig() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.OtherDockerConfig }).(pulumi.StringOutput)
}

func (o DuploServiceOutput) OtherDockerHostConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.OtherDockerHostConfig }).(pulumi.StringPtrOutput)
}

// The service's parent domain
func (o DuploServiceOutput) ParentDomain() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.ParentDomain }).(pulumi.StringOutput)
}

// Allow replica collocation for the service. If this is set then 2 replicas can be on the same host.
func (o DuploServiceOutput) ReplicaCollocationAllowed() pulumi.BoolOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolOutput { return v.ReplicaCollocationAllowed }).(pulumi.BoolOutput)
}

// The number of container replicas to deploy.
func (o DuploServiceOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.IntPtrOutput { return v.Replicas }).(pulumi.IntPtrOutput)
}

func (o DuploServiceOutput) ReplicasMatchingAsgName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.ReplicasMatchingAsgName }).(pulumi.StringPtrOutput)
}

// Whether or not the replicas must be spread across availability zones. Only supported on Kubernetes.
func (o DuploServiceOutput) ShouldSpreadAcrossZones() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.BoolPtrOutput { return v.ShouldSpreadAcrossZones }).(pulumi.BoolPtrOutput)
}

func (o DuploServiceOutput) Tags() DuploServiceTagArrayOutput {
	return o.ApplyT(func(v *DuploService) DuploServiceTagArrayOutput { return v.Tags }).(DuploServiceTagArrayOutput)
}

// The GUID of the tenant that the service will be created in.
func (o DuploServiceOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

// Volumes to be attached to pod.
func (o DuploServiceOutput) Volumes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DuploService) pulumi.StringPtrOutput { return v.Volumes }).(pulumi.StringPtrOutput)
}

type DuploServiceArrayOutput struct{ *pulumi.OutputState }

func (DuploServiceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DuploService)(nil)).Elem()
}

func (o DuploServiceArrayOutput) ToDuploServiceArrayOutput() DuploServiceArrayOutput {
	return o
}

func (o DuploServiceArrayOutput) ToDuploServiceArrayOutputWithContext(ctx context.Context) DuploServiceArrayOutput {
	return o
}

func (o DuploServiceArrayOutput) Index(i pulumi.IntInput) DuploServiceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DuploService {
		return vs[0].([]*DuploService)[vs[1].(int)]
	}).(DuploServiceOutput)
}

type DuploServiceMapOutput struct{ *pulumi.OutputState }

func (DuploServiceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DuploService)(nil)).Elem()
}

func (o DuploServiceMapOutput) ToDuploServiceMapOutput() DuploServiceMapOutput {
	return o
}

func (o DuploServiceMapOutput) ToDuploServiceMapOutputWithContext(ctx context.Context) DuploServiceMapOutput {
	return o
}

func (o DuploServiceMapOutput) MapIndex(k pulumi.StringInput) DuploServiceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DuploService {
		return vs[0].(map[string]*DuploService)[vs[1].(string)]
	}).(DuploServiceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DuploServiceInput)(nil)).Elem(), &DuploService{})
	pulumi.RegisterInputType(reflect.TypeOf((*DuploServiceArrayInput)(nil)).Elem(), DuploServiceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DuploServiceMapInput)(nil)).Elem(), DuploServiceMap{})
	pulumi.RegisterOutputType(DuploServiceOutput{})
	pulumi.RegisterOutputType(DuploServiceArrayOutput{})
	pulumi.RegisterOutputType(DuploServiceMapOutput{})
}
