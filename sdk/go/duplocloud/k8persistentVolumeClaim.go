// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package duplocloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `K8PersistentVolumeClaim` manages a kubernetes persistent volume claim in a Duplo tenant.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tenantId := "3a0b2ea5-7403-4765-ad6e-8771ca8fa0fd"
//			_, err := duplocloud.NewK8PersistentVolumeClaim(ctx, "pvc", &duplocloud.K8PersistentVolumeClaimArgs{
//				TenantId: pulumi.String(tenantId),
//				Name:     pulumi.String("pvc"),
//				Spec: &duplocloud.K8PersistentVolumeClaimSpecArgs{
//					AccessModes: pulumi.StringArray{
//						pulumi.String("ReadWriteMany"),
//					},
//					VolumeMode:       pulumi.String("Filesystem"),
//					StorageClassName: pulumi.String("duploservices-dev02-sc"),
//					Resources: &duplocloud.K8PersistentVolumeClaimSpecResourcesArgs{
//						Limits: pulumi.StringMap{
//							"storage": pulumi.String("20Gi"),
//						},
//						Requests: pulumi.StringMap{
//							"storage": pulumi.String("10Gi"),
//						},
//					},
//				},
//				Annotations: pulumi.StringMap{
//					"a1": pulumi.String("v1"),
//					"a2": pulumi.String("v2"),
//				},
//				Labels: pulumi.StringMap{
//					"l1": pulumi.String("v1"),
//					"l2": pulumi.String("v2"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Example: Importing an existing kubernetes Persistent Volume Claim
//
//   - *TENANT_ID* is the tenant GUID
//
//   - *NAME* is the name of Persistent Volume Claim
//
// #
//
// ```sh
// $ pulumi import duplocloud:index/k8PersistentVolumeClaim:K8PersistentVolumeClaim pvc v3/subscriptions/*TENANT_ID*/k8s/pvc/*NAME*
// ```
type K8PersistentVolumeClaim struct {
	pulumi.CustomResourceState

	// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The name of the persistent volume claim.
	Name pulumi.StringOutput `pulumi:"name"`
	// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
	Spec K8PersistentVolumeClaimSpecOutput `pulumi:"spec"`
	// The GUID of the tenant that the persistent volume claim will be created in.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
}

// NewK8PersistentVolumeClaim registers a new resource with the given unique name, arguments, and options.
func NewK8PersistentVolumeClaim(ctx *pulumi.Context,
	name string, args *K8PersistentVolumeClaimArgs, opts ...pulumi.ResourceOption) (*K8PersistentVolumeClaim, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource K8PersistentVolumeClaim
	err := ctx.RegisterResource("duplocloud:index/k8PersistentVolumeClaim:K8PersistentVolumeClaim", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetK8PersistentVolumeClaim gets an existing K8PersistentVolumeClaim resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetK8PersistentVolumeClaim(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *K8PersistentVolumeClaimState, opts ...pulumi.ResourceOption) (*K8PersistentVolumeClaim, error) {
	var resource K8PersistentVolumeClaim
	err := ctx.ReadResource("duplocloud:index/k8PersistentVolumeClaim:K8PersistentVolumeClaim", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering K8PersistentVolumeClaim resources.
type k8persistentVolumeClaimState struct {
	// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
	Annotations map[string]string `pulumi:"annotations"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
	Labels map[string]string `pulumi:"labels"`
	// The name of the persistent volume claim.
	Name *string `pulumi:"name"`
	// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
	Spec *K8PersistentVolumeClaimSpec `pulumi:"spec"`
	// The GUID of the tenant that the persistent volume claim will be created in.
	TenantId *string `pulumi:"tenantId"`
}

type K8PersistentVolumeClaimState struct {
	// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
	Labels pulumi.StringMapInput
	// The name of the persistent volume claim.
	Name pulumi.StringPtrInput
	// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
	Spec K8PersistentVolumeClaimSpecPtrInput
	// The GUID of the tenant that the persistent volume claim will be created in.
	TenantId pulumi.StringPtrInput
}

func (K8PersistentVolumeClaimState) ElementType() reflect.Type {
	return reflect.TypeOf((*k8persistentVolumeClaimState)(nil)).Elem()
}

type k8persistentVolumeClaimArgs struct {
	// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
	Annotations map[string]string `pulumi:"annotations"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
	Labels map[string]string `pulumi:"labels"`
	// The name of the persistent volume claim.
	Name *string `pulumi:"name"`
	// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
	Spec K8PersistentVolumeClaimSpec `pulumi:"spec"`
	// The GUID of the tenant that the persistent volume claim will be created in.
	TenantId string `pulumi:"tenantId"`
}

// The set of arguments for constructing a K8PersistentVolumeClaim resource.
type K8PersistentVolumeClaimArgs struct {
	// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
	Labels pulumi.StringMapInput
	// The name of the persistent volume claim.
	Name pulumi.StringPtrInput
	// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
	Spec K8PersistentVolumeClaimSpecInput
	// The GUID of the tenant that the persistent volume claim will be created in.
	TenantId pulumi.StringInput
}

func (K8PersistentVolumeClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*k8persistentVolumeClaimArgs)(nil)).Elem()
}

type K8PersistentVolumeClaimInput interface {
	pulumi.Input

	ToK8PersistentVolumeClaimOutput() K8PersistentVolumeClaimOutput
	ToK8PersistentVolumeClaimOutputWithContext(ctx context.Context) K8PersistentVolumeClaimOutput
}

func (*K8PersistentVolumeClaim) ElementType() reflect.Type {
	return reflect.TypeOf((**K8PersistentVolumeClaim)(nil)).Elem()
}

func (i *K8PersistentVolumeClaim) ToK8PersistentVolumeClaimOutput() K8PersistentVolumeClaimOutput {
	return i.ToK8PersistentVolumeClaimOutputWithContext(context.Background())
}

func (i *K8PersistentVolumeClaim) ToK8PersistentVolumeClaimOutputWithContext(ctx context.Context) K8PersistentVolumeClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8PersistentVolumeClaimOutput)
}

// K8PersistentVolumeClaimArrayInput is an input type that accepts K8PersistentVolumeClaimArray and K8PersistentVolumeClaimArrayOutput values.
// You can construct a concrete instance of `K8PersistentVolumeClaimArrayInput` via:
//
//	K8PersistentVolumeClaimArray{ K8PersistentVolumeClaimArgs{...} }
type K8PersistentVolumeClaimArrayInput interface {
	pulumi.Input

	ToK8PersistentVolumeClaimArrayOutput() K8PersistentVolumeClaimArrayOutput
	ToK8PersistentVolumeClaimArrayOutputWithContext(context.Context) K8PersistentVolumeClaimArrayOutput
}

type K8PersistentVolumeClaimArray []K8PersistentVolumeClaimInput

func (K8PersistentVolumeClaimArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8PersistentVolumeClaim)(nil)).Elem()
}

func (i K8PersistentVolumeClaimArray) ToK8PersistentVolumeClaimArrayOutput() K8PersistentVolumeClaimArrayOutput {
	return i.ToK8PersistentVolumeClaimArrayOutputWithContext(context.Background())
}

func (i K8PersistentVolumeClaimArray) ToK8PersistentVolumeClaimArrayOutputWithContext(ctx context.Context) K8PersistentVolumeClaimArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8PersistentVolumeClaimArrayOutput)
}

// K8PersistentVolumeClaimMapInput is an input type that accepts K8PersistentVolumeClaimMap and K8PersistentVolumeClaimMapOutput values.
// You can construct a concrete instance of `K8PersistentVolumeClaimMapInput` via:
//
//	K8PersistentVolumeClaimMap{ "key": K8PersistentVolumeClaimArgs{...} }
type K8PersistentVolumeClaimMapInput interface {
	pulumi.Input

	ToK8PersistentVolumeClaimMapOutput() K8PersistentVolumeClaimMapOutput
	ToK8PersistentVolumeClaimMapOutputWithContext(context.Context) K8PersistentVolumeClaimMapOutput
}

type K8PersistentVolumeClaimMap map[string]K8PersistentVolumeClaimInput

func (K8PersistentVolumeClaimMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8PersistentVolumeClaim)(nil)).Elem()
}

func (i K8PersistentVolumeClaimMap) ToK8PersistentVolumeClaimMapOutput() K8PersistentVolumeClaimMapOutput {
	return i.ToK8PersistentVolumeClaimMapOutputWithContext(context.Background())
}

func (i K8PersistentVolumeClaimMap) ToK8PersistentVolumeClaimMapOutputWithContext(ctx context.Context) K8PersistentVolumeClaimMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8PersistentVolumeClaimMapOutput)
}

type K8PersistentVolumeClaimOutput struct{ *pulumi.OutputState }

func (K8PersistentVolumeClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**K8PersistentVolumeClaim)(nil)).Elem()
}

func (o K8PersistentVolumeClaimOutput) ToK8PersistentVolumeClaimOutput() K8PersistentVolumeClaimOutput {
	return o
}

func (o K8PersistentVolumeClaimOutput) ToK8PersistentVolumeClaimOutputWithContext(ctx context.Context) K8PersistentVolumeClaimOutput {
	return o
}

// An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata.
func (o K8PersistentVolumeClaimOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8PersistentVolumeClaim) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// Map of string keys and values that can be used to organize and categorize (scope and select) the service.
func (o K8PersistentVolumeClaimOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8PersistentVolumeClaim) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The name of the persistent volume claim.
func (o K8PersistentVolumeClaimOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *K8PersistentVolumeClaim) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Spec defines the desired characteristics of a volume requested by a pod author. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
func (o K8PersistentVolumeClaimOutput) Spec() K8PersistentVolumeClaimSpecOutput {
	return o.ApplyT(func(v *K8PersistentVolumeClaim) K8PersistentVolumeClaimSpecOutput { return v.Spec }).(K8PersistentVolumeClaimSpecOutput)
}

// The GUID of the tenant that the persistent volume claim will be created in.
func (o K8PersistentVolumeClaimOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *K8PersistentVolumeClaim) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

type K8PersistentVolumeClaimArrayOutput struct{ *pulumi.OutputState }

func (K8PersistentVolumeClaimArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8PersistentVolumeClaim)(nil)).Elem()
}

func (o K8PersistentVolumeClaimArrayOutput) ToK8PersistentVolumeClaimArrayOutput() K8PersistentVolumeClaimArrayOutput {
	return o
}

func (o K8PersistentVolumeClaimArrayOutput) ToK8PersistentVolumeClaimArrayOutputWithContext(ctx context.Context) K8PersistentVolumeClaimArrayOutput {
	return o
}

func (o K8PersistentVolumeClaimArrayOutput) Index(i pulumi.IntInput) K8PersistentVolumeClaimOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *K8PersistentVolumeClaim {
		return vs[0].([]*K8PersistentVolumeClaim)[vs[1].(int)]
	}).(K8PersistentVolumeClaimOutput)
}

type K8PersistentVolumeClaimMapOutput struct{ *pulumi.OutputState }

func (K8PersistentVolumeClaimMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8PersistentVolumeClaim)(nil)).Elem()
}

func (o K8PersistentVolumeClaimMapOutput) ToK8PersistentVolumeClaimMapOutput() K8PersistentVolumeClaimMapOutput {
	return o
}

func (o K8PersistentVolumeClaimMapOutput) ToK8PersistentVolumeClaimMapOutputWithContext(ctx context.Context) K8PersistentVolumeClaimMapOutput {
	return o
}

func (o K8PersistentVolumeClaimMapOutput) MapIndex(k pulumi.StringInput) K8PersistentVolumeClaimOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *K8PersistentVolumeClaim {
		return vs[0].(map[string]*K8PersistentVolumeClaim)[vs[1].(string)]
	}).(K8PersistentVolumeClaimOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*K8PersistentVolumeClaimInput)(nil)).Elem(), &K8PersistentVolumeClaim{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8PersistentVolumeClaimArrayInput)(nil)).Elem(), K8PersistentVolumeClaimArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8PersistentVolumeClaimMapInput)(nil)).Elem(), K8PersistentVolumeClaimMap{})
	pulumi.RegisterOutputType(K8PersistentVolumeClaimOutput{})
	pulumi.RegisterOutputType(K8PersistentVolumeClaimArrayOutput{})
	pulumi.RegisterOutputType(K8PersistentVolumeClaimMapOutput{})
}
