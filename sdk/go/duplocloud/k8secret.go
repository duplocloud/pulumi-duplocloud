// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package duplocloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `K8Secret` manages a kubernetes secret in a Duplo tenant.
//
// ## Import
//
// Example: Importing an existing kubernetes secret
//
//   - *TENANT_ID* is the tenant GUID
//
//   - *NAME* is the config map name
//
// #
//
// ```sh
// $ pulumi import duplocloud:index/k8Secret:K8Secret myapp v2/subscriptions/*TENANT_ID*/K8SecretApiV2/*NAME*
// ```
type K8Secret struct {
	pulumi.CustomResourceState

	ClientSecretVersion pulumi.StringOutput `pulumi:"clientSecretVersion"`
	// Annotations for the secret
	SecretAnnotations pulumi.StringMapOutput `pulumi:"secretAnnotations"`
	// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
	SecretData pulumi.StringPtrOutput `pulumi:"secretData"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
	SecretLabels pulumi.StringMapOutput `pulumi:"secretLabels"`
	// The name of the secret.
	SecretName pulumi.StringOutput `pulumi:"secretName"`
	// The type of the secret.  Usually `"Opaque"`.
	SecretType    pulumi.StringOutput `pulumi:"secretType"`
	SecretVersion pulumi.StringOutput `pulumi:"secretVersion"`
	// The GUID of the tenant that the secret will be created in.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
}

// NewK8Secret registers a new resource with the given unique name, arguments, and options.
func NewK8Secret(ctx *pulumi.Context,
	name string, args *K8SecretArgs, opts ...pulumi.ResourceOption) (*K8Secret, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SecretName == nil {
		return nil, errors.New("invalid value for required argument 'SecretName'")
	}
	if args.SecretType == nil {
		return nil, errors.New("invalid value for required argument 'SecretType'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	if args.SecretData != nil {
		args.SecretData = pulumi.ToSecret(args.SecretData).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"secretData",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource K8Secret
	err := ctx.RegisterResource("duplocloud:index/k8Secret:K8Secret", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetK8Secret gets an existing K8Secret resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetK8Secret(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *K8SecretState, opts ...pulumi.ResourceOption) (*K8Secret, error) {
	var resource K8Secret
	err := ctx.ReadResource("duplocloud:index/k8Secret:K8Secret", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering K8Secret resources.
type k8secretState struct {
	ClientSecretVersion *string `pulumi:"clientSecretVersion"`
	// Annotations for the secret
	SecretAnnotations map[string]string `pulumi:"secretAnnotations"`
	// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
	SecretData *string `pulumi:"secretData"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
	SecretLabels map[string]string `pulumi:"secretLabels"`
	// The name of the secret.
	SecretName *string `pulumi:"secretName"`
	// The type of the secret.  Usually `"Opaque"`.
	SecretType    *string `pulumi:"secretType"`
	SecretVersion *string `pulumi:"secretVersion"`
	// The GUID of the tenant that the secret will be created in.
	TenantId *string `pulumi:"tenantId"`
}

type K8SecretState struct {
	ClientSecretVersion pulumi.StringPtrInput
	// Annotations for the secret
	SecretAnnotations pulumi.StringMapInput
	// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
	SecretData pulumi.StringPtrInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
	SecretLabels pulumi.StringMapInput
	// The name of the secret.
	SecretName pulumi.StringPtrInput
	// The type of the secret.  Usually `"Opaque"`.
	SecretType    pulumi.StringPtrInput
	SecretVersion pulumi.StringPtrInput
	// The GUID of the tenant that the secret will be created in.
	TenantId pulumi.StringPtrInput
}

func (K8SecretState) ElementType() reflect.Type {
	return reflect.TypeOf((*k8secretState)(nil)).Elem()
}

type k8secretArgs struct {
	// Annotations for the secret
	SecretAnnotations map[string]string `pulumi:"secretAnnotations"`
	// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
	SecretData *string `pulumi:"secretData"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
	SecretLabels map[string]string `pulumi:"secretLabels"`
	// The name of the secret.
	SecretName string `pulumi:"secretName"`
	// The type of the secret.  Usually `"Opaque"`.
	SecretType string `pulumi:"secretType"`
	// The GUID of the tenant that the secret will be created in.
	TenantId string `pulumi:"tenantId"`
}

// The set of arguments for constructing a K8Secret resource.
type K8SecretArgs struct {
	// Annotations for the secret
	SecretAnnotations pulumi.StringMapInput
	// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
	SecretData pulumi.StringPtrInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
	SecretLabels pulumi.StringMapInput
	// The name of the secret.
	SecretName pulumi.StringInput
	// The type of the secret.  Usually `"Opaque"`.
	SecretType pulumi.StringInput
	// The GUID of the tenant that the secret will be created in.
	TenantId pulumi.StringInput
}

func (K8SecretArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*k8secretArgs)(nil)).Elem()
}

type K8SecretInput interface {
	pulumi.Input

	ToK8SecretOutput() K8SecretOutput
	ToK8SecretOutputWithContext(ctx context.Context) K8SecretOutput
}

func (*K8Secret) ElementType() reflect.Type {
	return reflect.TypeOf((**K8Secret)(nil)).Elem()
}

func (i *K8Secret) ToK8SecretOutput() K8SecretOutput {
	return i.ToK8SecretOutputWithContext(context.Background())
}

func (i *K8Secret) ToK8SecretOutputWithContext(ctx context.Context) K8SecretOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8SecretOutput)
}

// K8SecretArrayInput is an input type that accepts K8SecretArray and K8SecretArrayOutput values.
// You can construct a concrete instance of `K8SecretArrayInput` via:
//
//	K8SecretArray{ K8SecretArgs{...} }
type K8SecretArrayInput interface {
	pulumi.Input

	ToK8SecretArrayOutput() K8SecretArrayOutput
	ToK8SecretArrayOutputWithContext(context.Context) K8SecretArrayOutput
}

type K8SecretArray []K8SecretInput

func (K8SecretArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8Secret)(nil)).Elem()
}

func (i K8SecretArray) ToK8SecretArrayOutput() K8SecretArrayOutput {
	return i.ToK8SecretArrayOutputWithContext(context.Background())
}

func (i K8SecretArray) ToK8SecretArrayOutputWithContext(ctx context.Context) K8SecretArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8SecretArrayOutput)
}

// K8SecretMapInput is an input type that accepts K8SecretMap and K8SecretMapOutput values.
// You can construct a concrete instance of `K8SecretMapInput` via:
//
//	K8SecretMap{ "key": K8SecretArgs{...} }
type K8SecretMapInput interface {
	pulumi.Input

	ToK8SecretMapOutput() K8SecretMapOutput
	ToK8SecretMapOutputWithContext(context.Context) K8SecretMapOutput
}

type K8SecretMap map[string]K8SecretInput

func (K8SecretMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8Secret)(nil)).Elem()
}

func (i K8SecretMap) ToK8SecretMapOutput() K8SecretMapOutput {
	return i.ToK8SecretMapOutputWithContext(context.Background())
}

func (i K8SecretMap) ToK8SecretMapOutputWithContext(ctx context.Context) K8SecretMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8SecretMapOutput)
}

type K8SecretOutput struct{ *pulumi.OutputState }

func (K8SecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**K8Secret)(nil)).Elem()
}

func (o K8SecretOutput) ToK8SecretOutput() K8SecretOutput {
	return o
}

func (o K8SecretOutput) ToK8SecretOutputWithContext(ctx context.Context) K8SecretOutput {
	return o
}

func (o K8SecretOutput) ClientSecretVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringOutput { return v.ClientSecretVersion }).(pulumi.StringOutput)
}

// Annotations for the secret
func (o K8SecretOutput) SecretAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringMapOutput { return v.SecretAnnotations }).(pulumi.StringMapOutput)
}

// A JSON encoded string representing the secret metadata. You can use the `jsonencode()` function to convert map or object data, if needed. You can use the `jsondecode()` function to read data.
func (o K8SecretOutput) SecretData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringPtrOutput { return v.SecretData }).(pulumi.StringPtrOutput)
}

// Map of string keys and values that can be used to organize and categorize (scope and select) the secret
func (o K8SecretOutput) SecretLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringMapOutput { return v.SecretLabels }).(pulumi.StringMapOutput)
}

// The name of the secret.
func (o K8SecretOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringOutput { return v.SecretName }).(pulumi.StringOutput)
}

// The type of the secret.  Usually `"Opaque"`.
func (o K8SecretOutput) SecretType() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringOutput { return v.SecretType }).(pulumi.StringOutput)
}

func (o K8SecretOutput) SecretVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringOutput { return v.SecretVersion }).(pulumi.StringOutput)
}

// The GUID of the tenant that the secret will be created in.
func (o K8SecretOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Secret) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

type K8SecretArrayOutput struct{ *pulumi.OutputState }

func (K8SecretArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8Secret)(nil)).Elem()
}

func (o K8SecretArrayOutput) ToK8SecretArrayOutput() K8SecretArrayOutput {
	return o
}

func (o K8SecretArrayOutput) ToK8SecretArrayOutputWithContext(ctx context.Context) K8SecretArrayOutput {
	return o
}

func (o K8SecretArrayOutput) Index(i pulumi.IntInput) K8SecretOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *K8Secret {
		return vs[0].([]*K8Secret)[vs[1].(int)]
	}).(K8SecretOutput)
}

type K8SecretMapOutput struct{ *pulumi.OutputState }

func (K8SecretMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8Secret)(nil)).Elem()
}

func (o K8SecretMapOutput) ToK8SecretMapOutput() K8SecretMapOutput {
	return o
}

func (o K8SecretMapOutput) ToK8SecretMapOutputWithContext(ctx context.Context) K8SecretMapOutput {
	return o
}

func (o K8SecretMapOutput) MapIndex(k pulumi.StringInput) K8SecretOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *K8Secret {
		return vs[0].(map[string]*K8Secret)[vs[1].(string)]
	}).(K8SecretOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*K8SecretInput)(nil)).Elem(), &K8Secret{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8SecretArrayInput)(nil)).Elem(), K8SecretArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8SecretMapInput)(nil)).Elem(), K8SecretMap{})
	pulumi.RegisterOutputType(K8SecretOutput{})
	pulumi.RegisterOutputType(K8SecretArrayOutput{})
	pulumi.RegisterOutputType(K8SecretMapOutput{})
}
