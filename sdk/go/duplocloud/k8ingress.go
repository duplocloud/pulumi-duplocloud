// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package duplocloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/duplocloud/pulumi-duplocloud/sdk/go/duplocloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `K8Ingress` manages a kubernetes Ingress in a Duplo tenant.
//
// ## Import
//
// Example: Importing an existing kubernetes ingress
//
//   - *TENANT_ID* is the tenant GUID
//
//   - *NAME* is the ingress name
//
// #
//
// ```sh
// $ pulumi import duplocloud:index/k8Ingress:K8Ingress ingress v3/subscriptions/*TENANT_ID*/k8s/ingress/*NAME*
// ```
type K8Ingress struct {
	pulumi.CustomResourceState

	// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
	IngressClassName pulumi.StringOutput `pulumi:"ingressClassName"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
	Lbconfig K8IngressLbconfigOutput `pulumi:"lbconfig"`
	// The name of the Ingress.
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of host rules used to configure the Ingress.
	Rules K8IngressRuleArrayOutput `pulumi:"rules"`
	// The GUID of the tenant that the Ingress will be created in.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
	// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
	Tls K8IngressTlArrayOutput `pulumi:"tls"`
}

// NewK8Ingress registers a new resource with the given unique name, arguments, and options.
func NewK8Ingress(ctx *pulumi.Context,
	name string, args *K8IngressArgs, opts ...pulumi.ResourceOption) (*K8Ingress, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IngressClassName == nil {
		return nil, errors.New("invalid value for required argument 'IngressClassName'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource K8Ingress
	err := ctx.RegisterResource("duplocloud:index/k8Ingress:K8Ingress", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetK8Ingress gets an existing K8Ingress resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetK8Ingress(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *K8IngressState, opts ...pulumi.ResourceOption) (*K8Ingress, error) {
	var resource K8Ingress
	err := ctx.ReadResource("duplocloud:index/k8Ingress:K8Ingress", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering K8Ingress resources.
type k8ingressState struct {
	// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
	Annotations map[string]string `pulumi:"annotations"`
	// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
	IngressClassName *string `pulumi:"ingressClassName"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
	Labels map[string]string `pulumi:"labels"`
	// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
	Lbconfig *K8IngressLbconfig `pulumi:"lbconfig"`
	// The name of the Ingress.
	Name *string `pulumi:"name"`
	// A list of host rules used to configure the Ingress.
	Rules []K8IngressRule `pulumi:"rules"`
	// The GUID of the tenant that the Ingress will be created in.
	TenantId *string `pulumi:"tenantId"`
	// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
	Tls []K8IngressTl `pulumi:"tls"`
}

type K8IngressState struct {
	// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapInput
	// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
	IngressClassName pulumi.StringPtrInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
	Labels pulumi.StringMapInput
	// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
	Lbconfig K8IngressLbconfigPtrInput
	// The name of the Ingress.
	Name pulumi.StringPtrInput
	// A list of host rules used to configure the Ingress.
	Rules K8IngressRuleArrayInput
	// The GUID of the tenant that the Ingress will be created in.
	TenantId pulumi.StringPtrInput
	// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
	Tls K8IngressTlArrayInput
}

func (K8IngressState) ElementType() reflect.Type {
	return reflect.TypeOf((*k8ingressState)(nil)).Elem()
}

type k8ingressArgs struct {
	// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
	Annotations map[string]string `pulumi:"annotations"`
	// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
	IngressClassName string `pulumi:"ingressClassName"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
	Labels map[string]string `pulumi:"labels"`
	// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
	Lbconfig *K8IngressLbconfig `pulumi:"lbconfig"`
	// The name of the Ingress.
	Name *string `pulumi:"name"`
	// A list of host rules used to configure the Ingress.
	Rules []K8IngressRule `pulumi:"rules"`
	// The GUID of the tenant that the Ingress will be created in.
	TenantId string `pulumi:"tenantId"`
	// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
	Tls []K8IngressTl `pulumi:"tls"`
}

// The set of arguments for constructing a K8Ingress resource.
type K8IngressArgs struct {
	// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
	Annotations pulumi.StringMapInput
	// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
	IngressClassName pulumi.StringInput
	// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
	Labels pulumi.StringMapInput
	// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
	Lbconfig K8IngressLbconfigPtrInput
	// The name of the Ingress.
	Name pulumi.StringPtrInput
	// A list of host rules used to configure the Ingress.
	Rules K8IngressRuleArrayInput
	// The GUID of the tenant that the Ingress will be created in.
	TenantId pulumi.StringInput
	// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
	Tls K8IngressTlArrayInput
}

func (K8IngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*k8ingressArgs)(nil)).Elem()
}

type K8IngressInput interface {
	pulumi.Input

	ToK8IngressOutput() K8IngressOutput
	ToK8IngressOutputWithContext(ctx context.Context) K8IngressOutput
}

func (*K8Ingress) ElementType() reflect.Type {
	return reflect.TypeOf((**K8Ingress)(nil)).Elem()
}

func (i *K8Ingress) ToK8IngressOutput() K8IngressOutput {
	return i.ToK8IngressOutputWithContext(context.Background())
}

func (i *K8Ingress) ToK8IngressOutputWithContext(ctx context.Context) K8IngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8IngressOutput)
}

// K8IngressArrayInput is an input type that accepts K8IngressArray and K8IngressArrayOutput values.
// You can construct a concrete instance of `K8IngressArrayInput` via:
//
//	K8IngressArray{ K8IngressArgs{...} }
type K8IngressArrayInput interface {
	pulumi.Input

	ToK8IngressArrayOutput() K8IngressArrayOutput
	ToK8IngressArrayOutputWithContext(context.Context) K8IngressArrayOutput
}

type K8IngressArray []K8IngressInput

func (K8IngressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8Ingress)(nil)).Elem()
}

func (i K8IngressArray) ToK8IngressArrayOutput() K8IngressArrayOutput {
	return i.ToK8IngressArrayOutputWithContext(context.Background())
}

func (i K8IngressArray) ToK8IngressArrayOutputWithContext(ctx context.Context) K8IngressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8IngressArrayOutput)
}

// K8IngressMapInput is an input type that accepts K8IngressMap and K8IngressMapOutput values.
// You can construct a concrete instance of `K8IngressMapInput` via:
//
//	K8IngressMap{ "key": K8IngressArgs{...} }
type K8IngressMapInput interface {
	pulumi.Input

	ToK8IngressMapOutput() K8IngressMapOutput
	ToK8IngressMapOutputWithContext(context.Context) K8IngressMapOutput
}

type K8IngressMap map[string]K8IngressInput

func (K8IngressMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8Ingress)(nil)).Elem()
}

func (i K8IngressMap) ToK8IngressMapOutput() K8IngressMapOutput {
	return i.ToK8IngressMapOutputWithContext(context.Background())
}

func (i K8IngressMap) ToK8IngressMapOutputWithContext(ctx context.Context) K8IngressMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8IngressMapOutput)
}

type K8IngressOutput struct{ *pulumi.OutputState }

func (K8IngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**K8Ingress)(nil)).Elem()
}

func (o K8IngressOutput) ToK8IngressOutput() K8IngressOutput {
	return o
}

func (o K8IngressOutput) ToK8IngressOutputWithContext(ctx context.Context) K8IngressOutput {
	return o
}

// An unstructured key value map stored with the ingress that may be used to store arbitrary metadata.
func (o K8IngressOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8Ingress) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// The ingress class name references an IngressClass resource that contains additional configuration including the name of the controller that should implement the class.
func (o K8IngressOutput) IngressClassName() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Ingress) pulumi.StringOutput { return v.IngressClassName }).(pulumi.StringOutput)
}

// Map of string keys and values that can be used to organize and categorize (scope and select) the service. May match selectors of replication controllers and services.
func (o K8IngressOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *K8Ingress) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The load balancer configuration. This is required when `ingressClassName` is set to `alb`.
func (o K8IngressOutput) Lbconfig() K8IngressLbconfigOutput {
	return o.ApplyT(func(v *K8Ingress) K8IngressLbconfigOutput { return v.Lbconfig }).(K8IngressLbconfigOutput)
}

// The name of the Ingress.
func (o K8IngressOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Ingress) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A list of host rules used to configure the Ingress.
func (o K8IngressOutput) Rules() K8IngressRuleArrayOutput {
	return o.ApplyT(func(v *K8Ingress) K8IngressRuleArrayOutput { return v.Rules }).(K8IngressRuleArrayOutput)
}

// The GUID of the tenant that the Ingress will be created in.
func (o K8IngressOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *K8Ingress) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

// Block represents the TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI
func (o K8IngressOutput) Tls() K8IngressTlArrayOutput {
	return o.ApplyT(func(v *K8Ingress) K8IngressTlArrayOutput { return v.Tls }).(K8IngressTlArrayOutput)
}

type K8IngressArrayOutput struct{ *pulumi.OutputState }

func (K8IngressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8Ingress)(nil)).Elem()
}

func (o K8IngressArrayOutput) ToK8IngressArrayOutput() K8IngressArrayOutput {
	return o
}

func (o K8IngressArrayOutput) ToK8IngressArrayOutputWithContext(ctx context.Context) K8IngressArrayOutput {
	return o
}

func (o K8IngressArrayOutput) Index(i pulumi.IntInput) K8IngressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *K8Ingress {
		return vs[0].([]*K8Ingress)[vs[1].(int)]
	}).(K8IngressOutput)
}

type K8IngressMapOutput struct{ *pulumi.OutputState }

func (K8IngressMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8Ingress)(nil)).Elem()
}

func (o K8IngressMapOutput) ToK8IngressMapOutput() K8IngressMapOutput {
	return o
}

func (o K8IngressMapOutput) ToK8IngressMapOutputWithContext(ctx context.Context) K8IngressMapOutput {
	return o
}

func (o K8IngressMapOutput) MapIndex(k pulumi.StringInput) K8IngressOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *K8Ingress {
		return vs[0].(map[string]*K8Ingress)[vs[1].(string)]
	}).(K8IngressOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*K8IngressInput)(nil)).Elem(), &K8Ingress{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8IngressArrayInput)(nil)).Elem(), K8IngressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8IngressMapInput)(nil)).Elem(), K8IngressMap{})
	pulumi.RegisterOutputType(K8IngressOutput{})
	pulumi.RegisterOutputType(K8IngressArrayOutput{})
	pulumi.RegisterOutputType(K8IngressMapOutput{})
}
